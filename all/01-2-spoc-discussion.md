<div>请分析em.c，并补充cpu.md中描述不够或错误的地方。包括：在v9-cpu中如何实现时钟中断的；v9-cpu指令，关键变量描述有误或不全的情况；在v9-cpu中的跳转相关操作是如何实现的；在v9-cpu中如何设计相应指令，可有效实现函数调用与返回；emhello/os0/os1等程序被加载到内存的哪个位置,其堆栈是如何设置的；在v9-cpu中如何完成一次内存地址的读写的；在v9-cpu中如何实现分页机制；</div><div>时钟中断：</div><div>•<span class="Apple-tab-span" style="white-space:pre">	</span>每一个时钟周期，若设置了timeout，则timer+=delta，若timer&gt;=timeout 会把trap设为mtimer 并且goto到interrupt执行有关中断的指令。</div><div>关键变量：</div><div>•<span class="Apple-tab-span" style="white-space:pre">	</span>ssp:系统堆栈指针</div><div>•<span class="Apple-tab-span" style="white-space:pre">	</span>usp:用户堆栈指针</div><div>•<span class="Apple-tab-span" style="white-space:pre">	</span>cycle:循环计数</div><div>•<span class="Apple-tab-span" style="white-space:pre">	</span>xcycle:4*cycle</div><div>•<span class="Apple-tab-span" style="white-space:pre">	</span>timer:计时器</div><div>•<span class="Apple-tab-span" style="white-space:pre">	</span>timeout：计时器到时间后，跳转到interrupt</div><div>•<span class="Apple-tab-span" style="white-space:pre">	</span>delta：时钟周期长度</div><div>跳转相关操作：</div><div>•<span class="Apple-tab-span" style="white-space:pre">	</span>JMP:跳转到operand0</div><div>•<span class="Apple-tab-span" style="white-space:pre">	</span>JMPI:跳转懂啊operand0加上一个常量</div><div>•<span class="Apple-tab-span" style="white-space:pre">	</span>JSR：跳转到operand0并保存PC</div><div>•<span class="Apple-tab-span" style="white-space:pre">	</span>JSRA：跳转到operand0加上一个常量，并保存PC</div><div>•<span class="Apple-tab-span" style="white-space:pre">	</span>还有很多Branch相关操作可以进行条件跳转</div><div>函数调用和返回：</div><div>•<span class="Apple-tab-span" style="white-space:pre">	</span>利用JSR、JSRA跳转到相应函数位置实现调用，此时原先的PC被保存到寄存器，执行完函数后再跳转到寄存器所保存的值即可返回。函数调用跳转前参数被保存在堆栈内。</div><div>程序加载到内存哪个位置：</div><div>•<span class="Apple-tab-span" style="white-space:pre">	</span>程序加载到内存起始位置，注意到688行read函数中的(void*)mem。</div><div>•<span class="Apple-tab-span" style="white-space:pre">	</span>堆栈从底部向上进行。</div><div>内存地址的读写：</div><div>•<span class="Apple-tab-span" style="white-space:pre">	</span>先获得虚拟地址，右移12位获得虚拟页号，在tr/tw数组中寻找对应的物理页号，若没有则调用rlook/vlook函数寻找对应的物理页号。得到物理页号后，将虚拟地址翻译成物理地址，然后根据offset获得对应的位置进行读写操作。</div><div>分页机制：</div><div>•<span class="Apple-tab-span" style="white-space:pre">	</span>每页的大小是4096bit，</div><div>•<span class="Apple-tab-span" style="white-space:pre">	</span>TLB中有4个转换表分别是内核和用户的读写转换表。</div><div>•<span class="Apple-tab-span" style="white-space:pre">	</span>tr，tw指针指向用户或内核的读写表。</div><div><span class="Apple-tab-span" style="white-space:pre">	</span></div><div>请编写一个小程序，在v9-cpu下，能够接收你输入的字符并输出你输入的字符</div><div>#include &lt;u.h&gt;</div><div><br /></div><div>ivec(void *isr)</div><div>{</div><div>&nbsp; asm(LL,8);</div><div>&nbsp; asm(IVEC);</div><div>}</div><div><br /></div><div>inout()</div><div>{</div><div>&nbsp; asm(BIN);</div><div>&nbsp; asm(LBA);</div><div>&nbsp; asm(LI,1);</div><div>&nbsp; asm(BOUT);</div><div>}</div><div><br /></div><div>trap()</div><div>{</div><div>&nbsp; inout(0);</div><div>&nbsp; asm(RTI);</div><div>}</div><div><br /></div><div>main()</div><div>{</div><div>&nbsp; ivec(trap);</div><div>&nbsp; asm(STI);</div><div>&nbsp; while(1);</div><div>&nbsp; asm(HALT);</div><div>}</div><div>请编写一个小程序，在v9-cpu下，能够产生各种异常/中断</div><div>//question2 test interruption</div><div><br /></div><div>#include &lt;u.h&gt;</div><div><br /></div><div>enum { // page table entry flags</div><div>&nbsp; PTE_P &nbsp; = 0x001, &nbsp; &nbsp; &nbsp; // Present</div><div>&nbsp; PTE_W &nbsp; = 0x002, &nbsp; &nbsp; &nbsp; // Writeable</div><div>&nbsp; PTE_U &nbsp; = 0x004, &nbsp; &nbsp; &nbsp; // User</div><div>//PTE_PWT = 0x008, &nbsp; &nbsp; &nbsp; // Write-Through</div><div>//PTE_PCD = 0x010, &nbsp; &nbsp; &nbsp; // Cache-Disable</div><div>&nbsp; PTE_A &nbsp; = 0x020, &nbsp; &nbsp; &nbsp; // Accessed</div><div>&nbsp; PTE_D &nbsp; = 0x040, &nbsp; &nbsp; &nbsp; // Dirty</div><div>//PTE_PS &nbsp;= 0x080, &nbsp; &nbsp; &nbsp; // Page Size</div><div>//PTE_MBZ = 0x180, &nbsp; &nbsp; &nbsp; // Bits must be zero</div><div>};</div><div><br /></div><div>enum { // processor fault codes</div><div>&nbsp; FMEM, &nbsp; // bad physical address</div><div>&nbsp; FTIMER, // timer interrupt</div><div>&nbsp; FKEYBD, // keyboard interrupt</div><div>&nbsp; FPRIV, &nbsp;// privileged instruction</div><div>&nbsp; FINST, &nbsp;// illegal instruction</div><div>&nbsp; FSYS, &nbsp; // software trap</div><div>&nbsp; FARITH, // arithmetic trap</div><div>&nbsp; FIPAGE, // page fault on opcode fetch</div><div>&nbsp; FWPAGE, // page fault on write</div><div>&nbsp; FRPAGE, // page fault on read</div><div>&nbsp; USER=16 // user mode exception&nbsp;</div><div>};</div><div><br /></div><div>char pg_mem[6 * 4096]; // page dir + 4 entries + alignment</div><div><br /></div><div>int *pg_dir, *pg0, *pg1, *pg2, *pg3;</div><div><br /></div><div>int current;</div><div><br /></div><div>int in(port) &nbsp; &nbsp;{ asm(LL,8); asm(BIN); }</div><div>out(port, val) &nbsp;{ asm(LL,8); asm(LBL,16); asm(BOUT); }</div><div>ivec(void *isr) { asm(LL,8); asm(IVEC); }</div><div>lvadr() &nbsp; &nbsp; &nbsp; &nbsp; { asm(LVAD); }</div><div>stmr(int val) &nbsp; { asm(LL,8); asm(TIME); }</div><div>pdir(value) &nbsp; &nbsp; { asm(LL,8); asm(PDIR); }</div><div>spage(value) &nbsp; &nbsp;{ asm(LL,8); asm(SPAG); }</div><div>halt(value) &nbsp; &nbsp; { asm(LL,8); asm(HALT); }</div><div><br /></div><div>void *memcpy() { asm(LL,8); asm(LBL, 16); asm(LCL,24); asm(MCPY); asm(LL,8); }</div><div>void *memset() { asm(LL,8); asm(LBLB,16); asm(LCL,24); asm(MSET); asm(LL,8); }</div><div>void *memchr() { asm(LL,8); asm(LBLB,16); asm(LCL,24); asm(MCHR); }</div><div><br /></div><div>write(fd, char *p, n) { while (n--) out(fd, *p++); }</div><div><br /></div><div>int strlen(char *s) { return memchr(s, 0, -1) - (void *)s; }</div><div><br /></div><div>enum { BUFSIZ = 32 };</div><div>int vsprintf(char *s, char *f, va_list v)</div><div>{</div><div>&nbsp; char *e = s, *p, c, fill, b[BUFSIZ];</div><div>&nbsp; int i, left, fmax, fmin, sign;</div><div><br /></div><div>&nbsp; while (c = *f++) {</div><div>&nbsp; &nbsp; if (c != '%') { *e++ = c; continue; }</div><div>&nbsp; &nbsp; if (*f == '%') { *e++ = *f++; continue; }</div><div>&nbsp; &nbsp; if (left = (*f == '-')) f++;</div><div>&nbsp; &nbsp; fill = (*f == '0') ? *f++ : ' ';</div><div>&nbsp; &nbsp; fmin = sign = 0; fmax = BUFSIZ;</div><div>&nbsp; &nbsp; if (*f == '*') { fmin = va_arg(v,int); f++; } else while ('0' &lt;= *f &amp;&amp; *f &lt;= '9') fmin = fmin * 10 + *f++ - '0';</div><div>&nbsp; &nbsp; if (*f == '.') { if (*++f == '*') { fmax = va_arg(v,int); f++; } else for (fmax = 0; '0' &lt;= *f &amp;&amp; *f &lt;= '9'; fmax = fmax * 10 + *f++ - '0'); }</div><div>&nbsp; &nbsp; if (*f == 'l') f++;</div><div>&nbsp; &nbsp; switch (c = *f++) {</div><div>&nbsp; &nbsp; case 0: *e++ = '%'; *e = 0; return e - s;</div><div>&nbsp; &nbsp; case 'c': fill = ' '; i = (*(p = b) = va_arg(v,int)) ? 1 : 0; break;</div><div>&nbsp; &nbsp; case 's': fill = ' '; if (!(p = va_arg(v,char *))) p = "(null)"; if ((i = strlen(p)) &gt; fmax) i = fmax; break;</div><div>&nbsp; &nbsp; case 'u': i = va_arg(v,int); goto c1;</div><div>&nbsp; &nbsp; case 'd': if ((i = va_arg(v,int)) &lt; 0) { sign = 1; i = -i; } c1: p = b + BUFSIZ-1; do { *--p = ((uint)i % 10) + '0'; } while (i = (uint)i / 10); i = (b + BUFSIZ-1) - p; break;</div><div>&nbsp; &nbsp; case 'o': i = va_arg(v,int); p = b + BUFSIZ-1; do { *--p = (i &amp; 7) + '0'; } while (i = (uint)i &gt;&gt; 3); i = (b + BUFSIZ-1) - p; break;</div><div>&nbsp; &nbsp; case 'p': fill = '0'; fmin = 8; c = 'x';</div><div>&nbsp; &nbsp; case 'x': case 'X': c -= 33; i = va_arg(v,int); p = b + BUFSIZ-1; do { *--p = (i &amp; 15) + ((i &amp; 15) &gt; 9 ? c : '0'); } while (i = (uint)i &gt;&gt; 4); i = (b + BUFSIZ-1) - p; break;</div><div>&nbsp; &nbsp; default: *e++ = c; continue;</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; fmin -= i + sign;</div><div>&nbsp; &nbsp; if (sign &amp;&amp; fill == '0') *e++ = '-';</div><div>&nbsp; &nbsp; if (!left &amp;&amp; fmin &gt; 0) { memset(e, fill, fmin); e += fmin; }</div><div>&nbsp; &nbsp; if (sign &amp;&amp; fill == ' ') *e++ = '-';</div><div>&nbsp; &nbsp; memcpy(e, p, i); e += i;</div><div>&nbsp; &nbsp; if (left &amp;&amp; fmin &gt; 0) { memset(e, fill, fmin); e += fmin; }</div><div>&nbsp; }</div><div>&nbsp; *e = 0;</div><div>&nbsp; return e - s;</div><div>}</div><div><br /></div><div>int printf(char *f) { static char buf[4096]; return write(1, buf, vsprintf(buf, f, &amp;f)); } // XXX remove static from buf</div><div><br /></div><div>trap(int c, int b, int a, int fc, int pc)</div><div>{</div><div>&nbsp; printf("TRAP: ");</div><div>&nbsp; switch (fc) {</div><div>&nbsp; case FINST: &nbsp;printf("FINST"); break;</div><div>&nbsp; case FRPAGE: printf("FRPAGE [0x%08x]",lvadr()); break;</div><div>&nbsp; case FWPAGE: printf("FWPAGE [0x%08x]",lvadr()); break;</div><div>&nbsp; case FIPAGE: printf("FIPAGE [0x%08x]",lvadr()); break;</div><div>&nbsp; case FSYS: &nbsp; printf("FSYS"); break;</div><div>&nbsp; case FARITH: printf("FARITH"); break;</div><div>&nbsp; case FMEM: &nbsp; printf("FMEM [0x%08x]",lvadr()); break;</div><div>&nbsp; case FTIMER: printf("FTIMER"); current = 1; stmr(0); break;</div><div>&nbsp; case FKEYBD: printf("FKEYBD [%c]", in(0)); break;</div><div>&nbsp; default: &nbsp; &nbsp; printf("other [%d]",fc); break;</div><div>&nbsp; }</div><div>}</div><div><br /></div><div>alltraps()</div><div>{</div><div>&nbsp; asm(PSHA);</div><div>&nbsp; asm(PSHB);</div><div>&nbsp; asm(PSHC);</div><div>&nbsp; trap();</div><div>&nbsp; asm(POPC);</div><div>&nbsp; asm(POPB);</div><div>&nbsp; asm(POPA);</div><div>&nbsp; asm(RTI);</div><div>}</div><div><br /></div><div>setup_paging()</div><div>{</div><div>&nbsp; int i;</div><div>&nbsp;&nbsp;</div><div>&nbsp; pg_dir = (int *)((((int)&amp;pg_mem) + 4095) &amp; -4096);</div><div>&nbsp; pg0 = pg_dir + 1024;</div><div>&nbsp; pg1 = pg0 + 1024;</div><div>&nbsp; pg2 = pg1 + 1024;</div><div>&nbsp; pg3 = pg2 + 1024;</div><div>&nbsp;&nbsp;</div><div>&nbsp; pg_dir[0] = (int)pg0 | PTE_P | PTE_W | PTE_U; &nbsp;// identity map 16M</div><div>&nbsp; pg_dir[1] = (int)pg1 | PTE_P | PTE_W | PTE_U;</div><div>&nbsp; pg_dir[2] = (int)pg2 | PTE_P | PTE_W | PTE_U;</div><div>&nbsp; pg_dir[3] = (int)pg3 | PTE_P | PTE_W | PTE_U;</div><div>&nbsp; for (i=4;i&lt;1024;i++) pg_dir[i] = 0;</div><div>&nbsp;&nbsp;</div><div>&nbsp; for (i=0;i&lt;4096;i++) pg0[i] = (i&lt;&lt;12) | PTE_P | PTE_W | PTE_U; &nbsp;// trick to write all 4 contiguous pages</div><div>&nbsp;&nbsp;</div><div>&nbsp; pdir(pg_dir);</div><div>&nbsp; spage(1);</div><div>}</div><div><br /></div><div>main()</div><div>{</div><div>&nbsp; int t, d;&nbsp;</div><div>&nbsp;&nbsp;</div><div>&nbsp; current = 0;</div><div>&nbsp; ivec(alltraps);</div><div>&nbsp;&nbsp;</div><div>&nbsp; asm(STI);</div><div>&nbsp;&nbsp;</div><div>&nbsp; printf("test timer...");</div><div>&nbsp; t = 0;</div><div>&nbsp; stmr(10000);</div><div>&nbsp; while (!current) t++;</div><div>&nbsp; printf("(t=%d)...ok\n",t);</div><div>&nbsp;&nbsp;</div><div>&nbsp; printf("test invalid instruction...");</div><div>// &nbsp;asm(_dd); // XXX find a better way</div><div>&nbsp; asm(-1);</div><div>&nbsp; printf("...ok\n");</div><div>&nbsp;&nbsp;</div><div>&nbsp; printf("test bad physical address...");</div><div>&nbsp; t = *(int *)0x20000000;</div><div>&nbsp; printf("...ok\n");</div><div><br /></div><div>&nbsp; printf("test divide by zero...");</div><div>&nbsp; t = 10; d = 0; t /= d;</div><div>&nbsp; printf("...ok\n");</div><div>&nbsp;&nbsp;</div><div>&nbsp; printf("test paging...");</div><div>&nbsp; // reposition stack within first 16M</div><div>&nbsp; asm(LI, 4*1024*1024); // a = 4M</div><div>&nbsp; asm(SSP); // sp = a</div><div>&nbsp; setup_paging();</div><div>&nbsp; printf("identity map...ok\n");</div><div><br /></div><div>&nbsp; printf("test page fault read...");</div><div>&nbsp; pg0[50] = 0;</div><div>&nbsp; pdir(pg_dir);</div><div>&nbsp; t = *(int *)(50&lt;&lt;12);</div><div>&nbsp; printf("...ok\n");</div><div><br /></div><div>&nbsp; printf("test page fault write...");</div><div>&nbsp; *(int *)(50&lt;&lt;12) = 5;</div><div>&nbsp; printf("...ok\n");</div><div><br /></div><div>&nbsp; halt(0);</div><div>}</div><div>请编写一个小程序，在v9-cpu下，能够统计并显示内存大小</div><div><br /></div><div>#include &lt;u.h&gt;</div><div><br /></div><div>enum { // processor fault codes</div><div>&nbsp; FMEM, &nbsp; // bad physical address</div><div>&nbsp; FTIMER, // timer interrupt</div><div>&nbsp; FKEYBD, // keyboard interrupt</div><div>&nbsp; FPRIV, &nbsp;// privileged instruction</div><div>&nbsp; FINST, &nbsp;// illegal instruction</div><div>&nbsp; FSYS, &nbsp; // software trap</div><div>&nbsp; FARITH, // arithmetic trap</div><div>&nbsp; FIPAGE, // page fault on opcode fetch</div><div>&nbsp; FWPAGE, // page fault on write</div><div>&nbsp; FRPAGE, // page fault on read</div><div>&nbsp; USER=16 // user mode exception</div><div>};</div><div><br /></div><div>int in(port) &nbsp; &nbsp;{ asm(LL,8); asm(BIN); }</div><div>out(port, val) &nbsp;{ asm(LL,8); asm(LBL,16); asm(BOUT); }</div><div>ivec(void *isr) { asm(LL,8); asm(IVEC); }</div><div>halt(value) &nbsp; &nbsp; { asm(LL,8); asm(HALT); }</div><div><br /></div><div>void *memcpy() { asm(LL,8); asm(LBL, 16); asm(LCL,24); asm(MCPY); asm(LL,8); }</div><div>void *memset() { asm(LL,8); asm(LBLB,16); asm(LCL,24); asm(MSET); asm(LL,8); }</div><div>void *memchr() { asm(LL,8); asm(LBLB,16); asm(LCL,24); asm(MCHR); }</div><div><br /></div><div>write(fd, char *p, n) { while (n--) out(fd, *p++); }</div><div><br /></div><div>int strlen(char *s) { return memchr(s, 0, -1) - (void *)s; }</div><div><br /></div><div>enum { BUFSIZ = 32 };</div><div><br /></div><div>int vsprintf(char *s, char *f, va_list v)</div><div>{</div><div>&nbsp; char *e = s, *p, c, fill, b[BUFSIZ];</div><div>&nbsp; int i, left, fmax, fmin, sign;</div><div><br /></div><div>&nbsp; while (c = *f++) {</div><div>&nbsp; &nbsp; if (c != '%') { *e++ = c; continue; }</div><div>&nbsp; &nbsp; if (*f == '%') { *e++ = *f++; continue; }</div><div>&nbsp; &nbsp; if (left = (*f == '-')) f++;</div><div>&nbsp; &nbsp; fill = (*f == '0') ? *f++ : ' ';</div><div>&nbsp; &nbsp; fmin = sign = 0; fmax = BUFSIZ;</div><div>&nbsp; &nbsp; if (*f == '*') { fmin = va_arg(v,int); f++; } else while ('0' &lt;= *f &amp;&amp; *f &lt;= '9') fmin = fmin * 10 + *f++ - '0';</div><div>&nbsp; &nbsp; if (*f == '.') { if (*++f == '*') { fmax = va_arg(v,int); f++; } else for (fmax = 0; '0' &lt;= *f &amp;&amp; *f &lt;= '9'; fmax = fmax * 10 + *f++ - '0'); }</div><div>&nbsp; &nbsp; if (*f == 'l') f++;</div><div>&nbsp; &nbsp; switch (c = *f++) {</div><div>&nbsp; &nbsp; case 0: *e++ = '%'; *e = 0; return e - s;</div><div>&nbsp; &nbsp; case 'c': fill = ' '; i = (*(p = b) = va_arg(v,int)) ? 1 : 0; break;</div><div>&nbsp; &nbsp; case 's': fill = ' '; if (!(p = va_arg(v,char *))) p = "(null)"; if ((i = strlen(p)) &gt; fmax) i = fmax; break;</div><div>&nbsp; &nbsp; case 'u': i = va_arg(v,int); goto c1;</div><div>&nbsp; &nbsp; case 'd': if ((i = va_arg(v,int)) &lt; 0) { sign = 1; i = -i; } c1: p = b + BUFSIZ-1; do { *--p = ((uint)i % 10) + '0'; } while (i = (uint)i / 10); i = (b + BUFSIZ-1) - p; break;</div><div>&nbsp; &nbsp; case 'o': i = va_arg(v,int); p = b + BUFSIZ-1; do { *--p = (i &amp; 7) + '0'; } while (i = (uint)i &gt;&gt; 3); i = (b + BUFSIZ-1) - p; break;</div><div>&nbsp; &nbsp; case 'p': fill = '0'; fmin = 8; c = 'x';</div><div>&nbsp; &nbsp; case 'x': case 'X': c -= 33; i = va_arg(v,int); p = b + BUFSIZ-1; do { *--p = (i &amp; 15) + ((i &amp; 15) &gt; 9 ? c : '0'); } while (i = (uint)i &gt;&gt; 4); i = (b + BUFSIZ-1) - p; break;</div><div>&nbsp; &nbsp; default: *e++ = c; continue;</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; fmin -= i + sign;</div><div>&nbsp; &nbsp; if (sign &amp;&amp; fill == '0') *e++ = '-';</div><div>&nbsp; &nbsp; if (!left &amp;&amp; fmin &gt; 0) { memset(e, fill, fmin); e += fmin; }</div><div>&nbsp; &nbsp; if (sign &amp;&amp; fill == ' ') *e++ = '-';</div><div>&nbsp; &nbsp; memcpy(e, p, i); e += i;</div><div>&nbsp; &nbsp; if (left &amp;&amp; fmin &gt; 0) { memset(e, fill, fmin); e += fmin; }</div><div>&nbsp; }</div><div>&nbsp; *e = 0;</div><div>&nbsp; return e - s;</div><div>}</div><div><br /></div><div>int printf(char *f) { static char buf[4096]; return write(1, buf, vsprintf(buf, f, &amp;f)); }</div><div>int getmemsize(){asm(MSIZ);}//get memory size</div><div><br /></div><div>main()</div><div>{</div><div>&nbsp; printf("MEMSize: %d\n", getmemsize());</div><div>&nbsp; asm(LI,0);</div><div>&nbsp; asm(HALT);</div><div>}</div><div><br /></div>
